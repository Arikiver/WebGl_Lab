#include <glad/glad.h>
#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <vector>
#include <iostream>
#include <cmath>

// Shader source code
const char* vertexShaderSource = R"(
#version 330 core
layout(location = 0) in vec3 aPos;

out float depth;

uniform mat4 projection;
uniform mat4 view;
uniform mat4 model;

void main() {
 vec4 worldPosition = model * vec4(aPos, 1.0);
 depth = length(worldPosition.xyz); // Calculate distance from origin
 gl_Position = projection * view * worldPosition;
}
)";

const char* fragmentShaderSource = R"(
#version 330 core
in float depth;

out vec4 FragColor;

void main() {
 // Advanced vibrant color palette
 float normalizedDepth = clamp(depth / 5.0, 0.0, 1.0); // Adjust depth range
 vec3 color;
 color.r = 0.5 + 0.5 * sin(10.0 * normalizedDepth + 0.0);
 color.g = 0.5 + 0.5 * sin(10.0 * normalizedDepth + 2.0);
 color.b = 0.5 + 0.5 * sin(10.0 * normalizedDepth + 4.0);
 FragColor = vec4(color, 1.0);
}
)";

// Function to compile a shader
GLuint compileShader(GLenum type, const char* source) {
   GLuint shader = glCreateShader(type);
   glShaderSource(shader, 1, &source, nullptr);
   glCompileShader(shader);

   int success;
   glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
   if (!success) {
       char infoLog[512];
       glGetShaderInfoLog(shader, 512, nullptr, infoLog);
       std::cerr << "Shader Compilation Error: " << infoLog << std::endl;
   }
   return shader;
}

// Generate Mandelbulb points
std::vector<glm::vec3> generateMandelbulb(int maxIterations, float n, float step) {
   std::vector<glm::vec3> points;

   for (float x = -2.0; x <= 2.0; x += step) {
       for (float y = -2.0; y <= 2.0; y += step) {
           for (float z = -2.0; z <= 2.0; z += step) {
               glm::vec3 zVec = glm::vec3(0.0f, 0.0f, 0.0f);
               glm::vec3 c = glm::vec3(x, y, z);

               int iterations = 0;
               while (glm::length(zVec) <= 2.0f && iterations < maxIterations) {
                   float r = glm::length(zVec);
                   float phi = atan2(zVec.y, zVec.x);
                   float theta = atan2(zVec.z, sqrt(zVec.x * zVec.x + zVec.y * zVec.y));
                   float rn = pow(r, n);

                   zVec.x = rn * cos(n * phi) * cos(n * theta) + c.x;
                   zVec.y = rn * sin(n * phi) * cos(n * theta) + c.y;
                   zVec.z = rn * sin(n * theta) + c.z;

                   iterations++;
               }

               if (iterations == maxIterations) {
                   points.push_back(glm::vec3(x, y, z));
               }
           }
       }
   }

   return points;
}

bool isRotating = true; // Initially rotation is enabled

// Key callback function to toggle rotation
void keyCallback(GLFWwindow* window, int key, int scancode, int action, int mods) {
   if (key == GLFW_KEY_SPACE && action == GLFW_PRESS) {
       isRotating = !isRotating; // Toggle the rotation state
   }
}
int main() {
   // Initialize GLFW
   if (!glfwInit()) {
       std::cerr << "Failed to initialize GLFW!" << std::endl;
       return -1;
   }

   glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
   glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
   glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
   glfwWindowHint(GLFW_SAMPLES, 4); // Enable 4x MSAA

   GLFWwindow* window = glfwCreateWindow(1920, 1080, "Ultra-Quality Mandelbulb", nullptr, nullptr);
   if (!window) {
       std::cerr << "Failed to create GLFW window!" << std::endl;
       glfwTerminate();
       return -1;
   }
   glfwMakeContextCurrent(window);

   glfwSetKeyCallback(window, keyCallback); // Register the key callback

   // Load OpenGL with GLAD
   if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
       std::cerr << "Failed to initialize GLAD!" << std::endl;
       return -1;
   }

   glEnable(GL_DEPTH_TEST);
   glEnable(GL_MULTISAMPLE); // Enable MSAA

   GLuint vertexShader = compileShader(GL_VERTEX_SHADER, vertexShaderSource);
   GLuint fragmentShader = compileShader(GL_FRAGMENT_SHADER, fragmentShaderSource);

   GLuint shaderProgram = glCreateProgram();
   glAttachShader(shaderProgram, vertexShader);
   glAttachShader(shaderProgram, fragmentShader);
   glLinkProgram(shaderProgram);

   glDeleteShader(vertexShader);
   glDeleteShader(fragmentShader);

   // Increase points by reducing step size
   std::vector<glm::vec3> points = generateMandelbulb(50, 8.0f, 0.01f);

   GLuint vao, vbo;
   glGenVertexArrays(1, &vao);
   glGenBuffers(1, &vbo);

   glBindVertexArray(vao);
   glBindBuffer(GL_ARRAY_BUFFER, vbo);
   glBufferData(GL_ARRAY_BUFFER, points.size() * sizeof(glm::vec3), points.data(), GL_STATIC_DRAW);

   glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(glm::vec3), (void*)0);
   glEnableVertexAttribArray(0);

   glBindBuffer(GL_ARRAY_BUFFER, 0);
   glBindVertexArray(0);


   float rotationAngle = 0.0f; // Track the rotation angle
   float lastFrameTime = 0.0f; // Track time of the last frame

   while (!glfwWindowShouldClose(window)) {
       // Calculate delta time
       float currentFrameTime = glfwGetTime();
       float deltaTime = currentFrameTime - lastFrameTime;
       lastFrameTime = currentFrameTime;

       glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
       glUseProgram(shaderProgram);

       glm::mat4 projection = glm::perspective(glm::radians(45.0f), 1920.0f / 1080.0f, 0.1f, 100.0f);
       glm::mat4 view = glm::lookAt(glm::vec3(2.0f, 2.0f, 2.0f), glm::vec3(0.0f), glm::vec3(0.0f, 1.0f, 0.0f));

       if (isRotating) {
           rotationAngle += deltaTime * 0.5f; // Use delta time for smooth rotation
       }

       glm::mat4 model = glm::rotate(glm::mat4(1.0f), rotationAngle, glm::vec3(0.0f, 1.0f, 0.0f));
       model = glm::rotate(model, rotationAngle * 0.5f, glm::vec3(1.0f, 0.0f, 0.0f));

       GLuint projectionLoc = glGetUniformLocation(shaderProgram, "projection");
       GLuint viewLoc = glGetUniformLocation(shaderProgram, "view");
       GLuint modelLoc = glGetUniformLocation(shaderProgram, "model");

       glUniformMatrix4fv(projectionLoc, 1, GL_FALSE, glm::value_ptr(projection));
       glUniformMatrix4fv(viewLoc, 1, GL_FALSE, glm::value_ptr(view));
       glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model));

       glBindVertexArray(vao);
       glDrawArrays(GL_POINTS, 0, points.size());

       glfwSwapBuffers(window);
       glfwPollEvents();
   }

   glDeleteVertexArrays(1, &vao);
   glDeleteBuffers(1, &vbo);
   glDeleteProgram(shaderProgram);

   glfwDestroyWindow(window);
   glfwTerminate();
   return 0;
}
